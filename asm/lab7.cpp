#include <csignal>
#include <iostream>

// Функция вычисления 1/0, но не вызывающая исключения.
void invoke_divison_by_zero_without_exception() {
    int holder;  // Переменная для хранения "floating point control word".

    float one{ 1 };  // Значение с плавающей точкой равное 1.
    float zero{};    // Значение с плавающей точкой равное 0.
    float result;    // Переменная для хранения результата деления.

    // Ассемблерная вставка для вызова исключения деления на ноль.
    _asm {
        finit          // Инициализация сопроцессора FPU.
        fld one        // Загрузка значения "1" на вершину стека сопроцессора.
        fld zero       // Загрузка значения "0" на вершину стека сопроцессора.

        fdiv           // Деление двух верхних значений на стеке сопроцессора, 1.0 / 0.0 = INF.

        fstp result    // Сохранение результата деления в 'result'.
    }

    std::cout << "Without exception: 1.0 / 0.0 == " << result << "\n\n";
}

// Функция вычисления 1/0, вызывающая исключение.
void invoke_divison_by_zero_with_exception() {
    int holder;  // Переменная для хранения "floating point control word".

    float one{ 1 };  // Значение с плавающей точкой равное 1.
    float zero{};    // Значение с плавающей точкой равное 0.
    float result;    // Переменная для хранения результата деления.

    // Ассемблерная вставка для вызова исключения деления на ноль.
    _asm {
        finit          // Инициализация сопроцессора FPU.
        fld one        // Загрузка значения "1" на вершину стека сопроцессора.
        fld zero       // Загрузка значения "0" на вершину стека сопроцессора.

        fstcw holder   // Сохранение управляющего слова сопроцессора в 'holder'.
        not holder     // Инверсия битов 'holder'.
        or holder, 4   // Установка 4-го бита в 'holder' (маска исключения деления на ноль).
        not holder     // Инверсия битов 'holder'.
        fldcw holder   // Загрузка измененного управляющего слова сопроцессора обратно в сопроцессор.

        fdiv           // Деление двух верхних значений на стеке сопроцессора, 1.0 / 0.0 = INF.

        fstp result    // Сохранение результата деления в 'result'.
    }
}

// Функция для обработки исключения деления на ноль.
void division_by_zero_handler(int sig) {
    // Вывод номера сигнала с сообщением о том, что он был успешно пойман.
    std::cout << "Signal " << sig << " was caught!\n";
    // Успешное завершение всей программы.
    std::exit(EXIT_SUCCESS);
}

int main() {
    // Ввод 3 чисел с плавающей точкой.
    std::cout << "Enter 3 float numbers: ";
    float float1{}, float2{}, float3{};
    std::cin >> float1 >> float2 >> float3;
    // Ассемблерная вставка для сложения 3 чисел с плавающей точкой с использованием
    //  инструкций FPU и сохранения результата в 'float3'.
    _asm {
        finit        // Инициализация сопроцессора FPU.
        fld float1   // Загрузка значения float1 на вершину стека сопроцессора.
        fld float2   // Загрузка значения float2 на вершину стека сопроцессора.
        fadd         // Сложение двух верхних значений на стеке сопроцессора.
        fld float3   // Загрузка значения float3 на вершину стека сопроцессора.
        fadd         // Сложение двух верхних значений на стеке сопроцессора.
        fstp float3  // Сохранение результата сложения в переменную float3 и извлечение из стека.
    }
    // Вывод результата.
    std::cout << "Result == " << float3 << "\n\n";

    // Вызов функции вычисления 1.0/0.0, которая не должна выбросить исключения,
    //  поскольку мы не устанавливали бит ZM в маске.
    std::cout << "Invoking function that does 1.0/0.0, but doesn't throw exception,\n"
        << "because the mask bit(ZM) for the zero - divide exception is not set.\n";
    invoke_divison_by_zero_without_exception();

    // Установка обработчика сигнала для SIGFPE (исключение деления на ноль).
    signal(SIGFPE, division_by_zero_handler);
    // Вызов функции для вызова исключения деления на ноль, которая обязана выбросить исключение,
    //  поскольку мы установили бит ZM в маске внутри ассемблерной вставки в функции.
    std::cout << "Invoking function that does 1.0/0.0 and indeed do throw exception,\n"
        << "because the mask bit(ZM) for the zero - divide exception is set now!\n";
    invoke_divison_by_zero_with_exception();

    // Завершение программы с ошибкой, если исключение деления на ноль
    //  не было обработано правильно.
    // Мы никогда не должны оказаться здесь, если код работает корректно.
    return EXIT_FAILURE;
}
