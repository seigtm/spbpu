#include <cstdint>
#include <iostream>

// Флаг OF (OV в Visual Studio, overflow, флаг переполнения) изменяется только
//   в случае сдвига на 1 бит - он устанавливается, если изменилось значение 
//   старшего бита, и сбрасывается, если старший бит не изменился.
//   Для сдвигов на несколько бит, флаг OF неопределен.

// Флаг CF (CY в Visual Studio, carry, флаг переноса) становится равным
//   старшему биту операнда после сдвига.

// Флаги:
//   ZF (ZR, zero,   флаг нуля),
//   PF (PE, parity, флаг чётности),
//   SF (PL, sign,   флаг знака)
// устанавливаются в соответствии с результатом.

// Значение флага AF (AC, Auxiliary carry, вспомогательный флаг переноса) не определено.

// Если счетчик сдвига равен 0, то флаги не изменяются.

// Команда ROL выполняет побитовый сдвиг операнда влево.
// Старший бит операнда помещается на место младшего.
// Все биты операнда сдвигаются влево на место старших битов.
// Величина сдвига определяется вторым операндом.

namespace {

    std::int64_t x{ 0 };    // 64 бита, 8 байт.
    std::int64_t res{ 0 };  // 64 бита, 8 байт.

}  // namespace

// ROL Циклический сдвиг влево: регистры.
void rol_reg() {
    _asm {
        // Загрузка старших разрядов числа x из памяти в регистр eax.
        mov eax, edi
        // Сдвиг содержимого регистра eax на 63 бита вправо,
        //  чтобы остался только старший бит младшего разряда.
        shr eax, 63

        // Логический сдвиг содержимого регистра edx на 1 бит влево.
        shl edx, 1  // 10000101 << 1 = 00001010 <- дополняется нулями, вытесненное в CF.
        // Вращение влево на 1 бит содержимого регистра edi с переносом.
        rcl edi, 1  // 00001010 << 1 = 00010101 <- дополняется значением из CF, полученном выше.

        // Мы собираемся использовать OR, который очищает нужный нам флаг CF/CY.
        // Чтобы избежать такого поведения, положим в стэк флаги.
        pushf
        // Перенос одного бита из начала старшего разряда в конец младшего.
        or edx, eax
        // Восстановим предыдущее значение флагов.
        popf
    }
}

// ROL Циклический сдвиг влево: стэк.
void rol_stack(std::int64_t a, std::int64_t& b) {
    _asm {
        // Загрузка младших разрядов числа из памяти в регистр edx.
        mov edx, [ebp + 8]
        // Загрузка старших разрядов числа из памяти в регистр edi.
        mov edi, [ebp + 12]
        // Загрузка указателя на результат из памяти в регистр ebx.
        mov ebx, [ebp + 16]

        // Загрузка старших разрядов числа x из памяти в регистр eax.
        mov eax, edi
        // Сдвиг содержимого регистра ebx на 63 бита вправо,
        //  чтобы остался только старший бит младшего разряда.
        shr eax, 63

        // Логический сдвиг содержимого регистра edx на 1 бит влево.
        shl edx, 1  // 10000101 << 1 = 00001010 <- дополняется нулями, вытесненное в CF.
        // Вращение влево на 1 бит содержимого регистра edi с переносом.
        rcl edi, 1  // 00001010 << 1 = 00010101 <- дополняется значением из CF, полученном выше.

        // Мы собираемся использовать OR, который очищает нужный нам флаг CF/CY.
        // Чтобы избежать такого поведения, положим в стэк флаги.
        pushf
        // Перенос одного бита из начала старшего разряда в конец младшего.
        or edx, eax
        // Восстановим предыдущее значение флагов.
        popf

        // Загрузка эффективного адреса переменной res в регистр ebx.
        lea ebx, res
        // Сохранение результата в память.
        mov[ebx], edx
        mov[ebx + 4], edi
    }
}

// ROL Циклический сдвиг влево: общая память, с правильной логикой флагов.
void rol_shared_memory() {
    _asm {
        // Загрузка эффективного адреса переменной x в регистр esi.
        lea esi, x
        // Загрузка старших разрядов числа x из памяти в регистр edi.
        mov edi, [esi + 4]
        // Загрузка младших разрядов числа x из памяти в регистр edx.
        mov edx, [esi]

        // Загрузка старших разрядов числа x из памяти в регистр eax.
        mov eax, edi
        // Сдвиг содержимого регистра ebx на 63 бита вправо,
        //  чтобы остался только старший бит младшего разряда.
        shr eax, 63

        // Логический сдвиг содержимого регистра edx на 1 бит влево.
        shl edx, 1  // 10000101 << 1 = 00001010 <- дополняется нулями, вытесненное в CF.
        // Вращение влево на 1 бит содержимого регистра edi с переносом.
        rcl edi, 1  // 00001010 << 1 = 00010101 <- дополняется значением из CF, полученном выше.

        // Мы собираемся использовать OR, который очищает нужный нам флаг CF/CY.
        // Чтобы избежать такого поведения, положим в стэк флаги.
        pushf
        // Перенос одного бита из начала старшего разряда в конец младшего.
        or edx, eax
        // Восстановим предыдущее значение флагов.
        popf

        // Загрузка эффективного адреса переменной res в регистр ebx.
        lea ebx, res
        // Сохранение результата в память.
        mov[ebx], edx
        mov[ebx + 4], edi
    }
}

int main() {
    // 0. Встроенный ROL(5).
    ::x = 5;
    _asm {
        rol x, 1
    }
    std::cout << "TEST 1. ROL: expected = ROL(5) = 10, got = " << ::x << '\n';

    // 0. Встроенный ROL(UINT64_MAX).
    ::x = UINT64_MAX;
    _asm {
        rol x, 1
    }
    std::cout << "TEST 2. ROL: expected = ROL(UINT64_MAX) = -1, got = " << ::x << '\n';

    // 0. Встроенный ROL(-8).
    ::x = -8;
    _asm {
        rol x, 1
    }
    std::cout << "TEST 3. ROL: expected = ROL(-8) = -15, got = " << ::x << "\n\n";

    // 1. ROL через регистры.
    ::x = 5;
    ::res = 0;
    // Подготовка регистров перед выполнением ROL.
    _asm {
        // Загрузка адреса переменной x в регистр esi.
        lea esi, x
        // Загрузка старших разрядов числа x из памяти в регистр edi.
        mov edi, [esi + 4]
        // Загрузка младших разрядов числа x из памяти в регистр edx.
        mov edx, [esi]
        // Загрузка адреса переменной res в регистр ebx.
        lea ebx, res
    }
    rol_reg();
    // Результат в регистрах.
    _asm {
        // Сохранение результатов в память.
        mov[ebx], edx
        mov[ebx + 4], edi
    }
    std::cout << "1. ROL reg: expected = ROL(5) = 10, got = " << ::res << '\n';

    // 2. ROL через стэк.
    ::x = UINT64_MAX;
    rol_stack(::x, ::res);
    std::cout << "2. ROL stack: expected = ROL(UINT64_MAX) = -1, got = " << ::res << '\n';

    // 3. ROL через общую память.
    ::x = -8;
    rol_shared_memory();
    std::cout << "3. ROL shared memory: expected = ROL(-8) = -15, got = " << ::res << '\n';

    return EXIT_SUCCESS;
}
