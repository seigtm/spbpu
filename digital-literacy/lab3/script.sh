#!/bin/bash

### Основы разработки программного обеспечения, ИКНТ, Баранов К.П., группа 20021.
### Лабораторная работа #3.

cd temp

# 1. Есть файл, example.txt. Необходимо вывести на экран строчки содержащие символ `a`, но в обратном порядке.
grep -h 'a' example.txt | rev

# 2. Опишите, что делает команда: `ls -y >> logfile 2>&1`.
# Ответ: Пытается выполнить `ls -y` (`-y` - несуществующий ключ для команды `ls`).
#        `>>` Направляет стандартный поток вывода в файл `logfile`.
#           Если файл не существовал, он будет создан, если существует — данные будут дописаны в конец файла.
#        `2> &1` направляет стандартный поток ошибок в файл (`&1` раскрывается в `logfile`).

# 3. Напишите сценарий позволяющий вывести N строк файла начиная с заданной строки.
#    Номер заданной строки и их количество являются входными параметрами.
#    Задачу следует решать, используя стандартные утилиты и перенаправление ввода вывода.
start=2
n=10
sed -n "${start},+${n}p" file1
## Альтернатива, которая, правда, не имеет особого смысла:
## cat file1 >&1 | sed -n "2,+10p"

# 4. Дана команда: `ls file1 file2`.
#    Файл file1 существует, файл file2 не существует.
#    Перенаправьте только стандартную ошибку в конвейер, одновременно записывая номера строк (`nl`?) и перенаправьте вывод в файл.
#    Стандартный вывод должен отображаться на экране.
ls file1 file2 3>&1 1>&2 2>&3 | nl >errors
## Свап стандартной ошибки и стандартного вывода `3>&1 1>&2 2>&3`:
## - `3>&1` - делаю копию файлового дескриптора 1 (stdout, стандартный вывод).
## - `1>&2` - файловый дескриптор 1 теперь является stderr, стандартной ошибкой.
## - `2>&3` - файловый дескриптор 2 теперь является stdout, стандартным выводом.

cd ..
